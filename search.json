[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "probamosQuarto",
    "section": "",
    "text": "Tenemos una clase Order que es una clase normal, de la que deriban 3 clases Order: TakeAwayOrder EatInOrderRestaurant y ShippingOrder. Entonces teniendo en cuenta la futura escalabilidad, la eficiencia y la mantenibilidad del proyecto deberiamos barajar varias opciones para sintetizar la clase order y declararla de la mejor forma posible.\n\nTendriamos la opción de declararla como una clase abstracta.\nTendriamos la opción de declararla como una interfaz\nTendriamos la opción de dividirla y crear una interfaz y una clase abstracta\nImplementar la opción de dejarla como clase normal y para que no escale hacia abajo y crear seals.\nImpelentar records.\n\nAhora bien, en que posibles casos nos iria mejor una opción u otra? Pues vamos a descubrirlo.\n\n\n\nCuándo lo usariamos: Si Order tiene comportamiento o atributos comunes que sus subclases necesitan (como métodos o atributos compartidos), una clase abstracta es buena opción. Esto también asegura que Order no se pueda instanciar directamente, obligando a usar una de sus subclases.\nVentajas:\n\nPuedes implementar métodos compartidos que serán heredados por las subclases.\nPermite tener código común para evitar duplicación.\nFacilita la escalabilidad, ya que puedes añadir métodos o atributos comunes a las órdenes en una sola clase.\n\nDesventajas:\n\nJava solo permite herencia simple, así que si una subclase necesita heredar de otra clase, esto limitaría su flexibilidad.\nEjemplo: Imagina que quieres crear una clase OnlineOrder que herede tanto de Order (para obtener todos los métodos de pedido) como de otra clase Trackable que tenga lógica de rastreo.\nEn este ejemplo, Java no permite heredar de ambas clases Order y Trackable al mismo tiempo. Esto limita la flexibilidad, ya que no puedes reutilizar la funcionalidad de Trackable en OnlineOrder a través de la herencia múltiple.\nPuede no ser la mejor opción si tienes muchas subclases específicas y muy diferentes entre sí, ya que se podría perder claridad al tratar de abarcar demasiado en Order.\n\n\n\n\n\n\n\nCuándo la usariamos: Si Order no necesita guardar información específica (como variables o datos compartidos entre sus subclases) ni realizar tareas complejas, y solo queremos que actúe como una “lista de instrucciones” para decirle a cada tipo de orden qué métodos debe tener, una interfaz es la mejor opción.\nEn otras palabras, una interfaz Order sirve para definir qué métodos deben tener todas las órdenes (como procesarPedido() o cancelarPedido()), sin implementar cómo deben funcionar esos métodos.\nVentajas:\n\nLas subclases pueden implementar múltiples interfaces, dándote más flexibilidad.\nBuena opción si Order define solo comportamientos (métodos) y no necesita almacenar datos o lógica compartida.\n\nDesventajas:\n\nLas interfaces no pueden tener variables de instancia (aunque Java permite métodos por defecto), así que cualquier lógica común tendrá que implementarse en cada subclase o en una clase de utilidad.\nCuando usas una interfaz en lugar de una clase abstracta, no puedes implementar directamente ningún método con lógica común dentro de la interfaz (solo puedes definir el método). Esto significa que, si todas las subclases necesitan la misma lógica, cada una tiene que implementar esa lógica de manera repetida.\n\nImagina que tienes una interfaz Order con un método calculateTotal() que todas las órdenes deben tener, y todas las subclases (TakeAwayOrder, EatInOrderRestaurant, ShippingOrder) necesitan calcular el total de la misma manera. Si Order es una interfaz, cada subclase tiene que implementar calculateTotal() con la misma lógica.\n\n\nDuplicación de código: La lógica de calculateTotal() está repetida en cada subclase, lo que significa más código a mantener. Si necesitas cambiar la lógica de cálculo, tendrías que actualizarla en todas las subclases, lo cual es propenso a errores.\nMayor consumo de memoria y procesamiento: Cada subclase tiene su propia copia del método, lo cual consume más memoria. Además, si muchas subclases ejecutan la misma lógica por separado, se genera una pequeña sobrecarga en rendimiento.\n\n\n\n\n\n\n\n\nCuándo lo usarlamos: Si tienes una clase Order que necesita:\n\nLógica común (como métodos que todas las órdenes necesitan y que funcionan de la misma manera para todas).\nMétodos específicos que cada subclase debe implementar a su manera.\n\nEntonces puedes usar una interfaz y una clase abstracta juntas.\n\n\nInterfaz: Define qué métodos debe tener cada tipo de Order, sin decir cómo deben funcionar esos métodos. Solo establece la “lista de tareas” que cada orden debe cumplir.\nClase abstracta: Implementa la lógica común que todas las órdenes comparten y guarda los atributos o datos que serán iguales para todas. También puede “heredar” los métodos de la interfaz, de modo que las subclases tengan la “lista de tareas” de la interfaz más la lógica común.\n\n\nSupón que tienes una interfaz OrderActions y una clase abstracta OrderBase:\n\nInterfaz OrderActions: Define los métodos que cada orden debe tener, como calculateTotal().\nClase abstracta OrderBase: Contiene la lógica que será igual para todas las órdenes y guarda datos comunes (como el precio). Además, usa la interfaz para asegurarse de que cada subclase implemente los métodos definidos en OrderActions.\npublic interface OrderActions {\n    double calculateTotal();  // \"Todas las orders tendran este método\"\n}\n\n// La clase abstracta implementa lógica común y guarda datos\npublic abstract class OrderBase implements OrderActions {\n    private double basePrice;\n\n    public OrderBase(double basePrice) {\n        this.basePrice = basePrice;\n    }\n\n    public double getBasePrice() {\n        return basePrice;\n    }\n}\n\n// Subclase TakeAwayOrder\npublic class TakeAwayOrder extends OrderBase {\n    public TakeAwayOrder(double basePrice) {\n        super(basePrice);\n    }\n\n    @Override\n    public double calculateTotal() {\n        return getBasePrice() * 1.1; // Lógica específica para calcular total\n    }\n}\n\nVentajas:\n\nCombina la flexibilidad de las interfaces con la reutilización de la clase abstracta.\nPermite separar los métodos abstractos (definidos en la interfaz) de la implementación concreta (en la clase abstracta).\nEsto facilita la escalabilidad, ya que puedes añadir más interfaces según cambien los requerimientos.\n\nDesventajas:\n\nComplejidad adicional, ya que ahora hay dos entidades para representar Order.\nPuede ser excesivo si Order no tiene muchos métodos ni atributos compartidos.\n\n\n\n\n\n\n\nCuándo lo usariamos: Si quieres que Order sea extensible solo a un conjunto específico de subclases (como TakeAwayOrder, EatInOrderRestaurant, y ShippingOrder), una clase sellada es una opción excelente en Java 17+.\nVentajas:\n\nPermite restringir qué subclases pueden derivarse de Order, lo cual puede ser útil para la escalabilidad y la seguridad del diseño.\nMantiene Order como una clase concreta, evitando instancias fuera del conjunto limitado de subclases especificadas.\nFacilita la mantenibilidad, ya que no necesitas preocuparte por la introducción de nuevas subclases inesperadas.\n\nDesventajas:\n\nLimita la flexibilidad para futuras extensiones; si en el futuro necesitas más subclases, la clase Order tendrá que modificarse.\nSolo compatible con versiones modernas de Java.\n\n\n\n\n\n\n\nCuándo lo usariamos: Si Order es principalmente un contenedor de datos sin lógica o comportamiento, los records pueden ser una opción sencilla. Sería una buena opción si Order solo tiene campos y métodos simples para acceder a ellos, sin necesidad de personalizar su comportamiento.\nVentajas:\n\nSintaxis simple y menor código, ya que los records manejan automáticamente equals, hashCode, y toString.\nInmutabilidad por defecto, lo que es útil si no quieres que Order cambie una vez creado.\n\nDesventajas:\n\nLimitado en términos de funcionalidad: los records están diseñados para ser simples contenedores de datos, por lo que no se pueden añadir comportamientos complejos.\nPuede no ser una buena opción si Order necesita tener subclases con diferentes comportamientos.\n\n\n\n\n\n\n\nClase abstracta: Usar si Order tiene lógica compartida entre subclases.\nInterfaz: Usar si Order solo define métodos sin necesidad de lógica compartida.\nInterfaz + clase abstracta: Usar para combinar flexibilidad y reutilización de código compartido.\nClase sellada: Usar si solo quieres permitir un conjunto específico de subclases.\nRecords: Usar si Order es un simple contenedor de datos sin lógica ni subclases adicionales."
  },
  {
    "objectID": "index.html#declarar-order-como-una-clase-abstracta",
    "href": "index.html#declarar-order-como-una-clase-abstracta",
    "title": "probamosQuarto",
    "section": "",
    "text": "Cuándo lo usariamos: Si Order tiene comportamiento o atributos comunes que sus subclases necesitan (como métodos o atributos compartidos), una clase abstracta es buena opción. Esto también asegura que Order no se pueda instanciar directamente, obligando a usar una de sus subclases.\nVentajas:\n\nPuedes implementar métodos compartidos que serán heredados por las subclases.\nPermite tener código común para evitar duplicación.\nFacilita la escalabilidad, ya que puedes añadir métodos o atributos comunes a las órdenes en una sola clase.\n\nDesventajas:\n\nJava solo permite herencia simple, así que si una subclase necesita heredar de otra clase, esto limitaría su flexibilidad.\nEjemplo: Imagina que quieres crear una clase OnlineOrder que herede tanto de Order (para obtener todos los métodos de pedido) como de otra clase Trackable que tenga lógica de rastreo.\nEn este ejemplo, Java no permite heredar de ambas clases Order y Trackable al mismo tiempo. Esto limita la flexibilidad, ya que no puedes reutilizar la funcionalidad de Trackable en OnlineOrder a través de la herencia múltiple.\nPuede no ser la mejor opción si tienes muchas subclases específicas y muy diferentes entre sí, ya que se podría perder claridad al tratar de abarcar demasiado en Order."
  },
  {
    "objectID": "index.html#declarar-order-como-una-interfaz",
    "href": "index.html#declarar-order-como-una-interfaz",
    "title": "probamosQuarto",
    "section": "",
    "text": "Cuándo la usariamos: Si Order no necesita guardar información específica (como variables o datos compartidos entre sus subclases) ni realizar tareas complejas, y solo queremos que actúe como una “lista de instrucciones” para decirle a cada tipo de orden qué métodos debe tener, una interfaz es la mejor opción.\nEn otras palabras, una interfaz Order sirve para definir qué métodos deben tener todas las órdenes (como procesarPedido() o cancelarPedido()), sin implementar cómo deben funcionar esos métodos.\nVentajas:\n\nLas subclases pueden implementar múltiples interfaces, dándote más flexibilidad.\nBuena opción si Order define solo comportamientos (métodos) y no necesita almacenar datos o lógica compartida.\n\nDesventajas:\n\nLas interfaces no pueden tener variables de instancia (aunque Java permite métodos por defecto), así que cualquier lógica común tendrá que implementarse en cada subclase o en una clase de utilidad.\nCuando usas una interfaz en lugar de una clase abstracta, no puedes implementar directamente ningún método con lógica común dentro de la interfaz (solo puedes definir el método). Esto significa que, si todas las subclases necesitan la misma lógica, cada una tiene que implementar esa lógica de manera repetida.\n\nImagina que tienes una interfaz Order con un método calculateTotal() que todas las órdenes deben tener, y todas las subclases (TakeAwayOrder, EatInOrderRestaurant, ShippingOrder) necesitan calcular el total de la misma manera. Si Order es una interfaz, cada subclase tiene que implementar calculateTotal() con la misma lógica.\n\n\nDuplicación de código: La lógica de calculateTotal() está repetida en cada subclase, lo que significa más código a mantener. Si necesitas cambiar la lógica de cálculo, tendrías que actualizarla en todas las subclases, lo cual es propenso a errores.\nMayor consumo de memoria y procesamiento: Cada subclase tiene su propia copia del método, lo cual consume más memoria. Además, si muchas subclases ejecutan la misma lógica por separado, se genera una pequeña sobrecarga en rendimiento."
  },
  {
    "objectID": "index.html#dividir-y-crear-una-interfaz-y-una-clase-abstracta",
    "href": "index.html#dividir-y-crear-una-interfaz-y-una-clase-abstracta",
    "title": "probamosQuarto",
    "section": "",
    "text": "Cuándo lo usarlamos: Si tienes una clase Order que necesita:\n\nLógica común (como métodos que todas las órdenes necesitan y que funcionan de la misma manera para todas).\nMétodos específicos que cada subclase debe implementar a su manera.\n\nEntonces puedes usar una interfaz y una clase abstracta juntas.\n\n\nInterfaz: Define qué métodos debe tener cada tipo de Order, sin decir cómo deben funcionar esos métodos. Solo establece la “lista de tareas” que cada orden debe cumplir.\nClase abstracta: Implementa la lógica común que todas las órdenes comparten y guarda los atributos o datos que serán iguales para todas. También puede “heredar” los métodos de la interfaz, de modo que las subclases tengan la “lista de tareas” de la interfaz más la lógica común.\n\n\nSupón que tienes una interfaz OrderActions y una clase abstracta OrderBase:\n\nInterfaz OrderActions: Define los métodos que cada orden debe tener, como calculateTotal().\nClase abstracta OrderBase: Contiene la lógica que será igual para todas las órdenes y guarda datos comunes (como el precio). Además, usa la interfaz para asegurarse de que cada subclase implemente los métodos definidos en OrderActions.\npublic interface OrderActions {\n    double calculateTotal();  // \"Todas las orders tendran este método\"\n}\n\n// La clase abstracta implementa lógica común y guarda datos\npublic abstract class OrderBase implements OrderActions {\n    private double basePrice;\n\n    public OrderBase(double basePrice) {\n        this.basePrice = basePrice;\n    }\n\n    public double getBasePrice() {\n        return basePrice;\n    }\n}\n\n// Subclase TakeAwayOrder\npublic class TakeAwayOrder extends OrderBase {\n    public TakeAwayOrder(double basePrice) {\n        super(basePrice);\n    }\n\n    @Override\n    public double calculateTotal() {\n        return getBasePrice() * 1.1; // Lógica específica para calcular total\n    }\n}\n\nVentajas:\n\nCombina la flexibilidad de las interfaces con la reutilización de la clase abstracta.\nPermite separar los métodos abstractos (definidos en la interfaz) de la implementación concreta (en la clase abstracta).\nEsto facilita la escalabilidad, ya que puedes añadir más interfaces según cambien los requerimientos.\n\nDesventajas:\n\nComplejidad adicional, ya que ahora hay dos entidades para representar Order.\nPuede ser excesivo si Order no tiene muchos métodos ni atributos compartidos."
  },
  {
    "objectID": "index.html#dejarla-como-clase-normal-y-sellarla-sealed",
    "href": "index.html#dejarla-como-clase-normal-y-sellarla-sealed",
    "title": "probamosQuarto",
    "section": "",
    "text": "Cuándo lo usariamos: Si quieres que Order sea extensible solo a un conjunto específico de subclases (como TakeAwayOrder, EatInOrderRestaurant, y ShippingOrder), una clase sellada es una opción excelente en Java 17+.\nVentajas:\n\nPermite restringir qué subclases pueden derivarse de Order, lo cual puede ser útil para la escalabilidad y la seguridad del diseño.\nMantiene Order como una clase concreta, evitando instancias fuera del conjunto limitado de subclases especificadas.\nFacilita la mantenibilidad, ya que no necesitas preocuparte por la introducción de nuevas subclases inesperadas.\n\nDesventajas:\n\nLimita la flexibilidad para futuras extensiones; si en el futuro necesitas más subclases, la clase Order tendrá que modificarse.\nSolo compatible con versiones modernas de Java."
  },
  {
    "objectID": "index.html#implementar-records",
    "href": "index.html#implementar-records",
    "title": "probamosQuarto",
    "section": "",
    "text": "Cuándo lo usariamos: Si Order es principalmente un contenedor de datos sin lógica o comportamiento, los records pueden ser una opción sencilla. Sería una buena opción si Order solo tiene campos y métodos simples para acceder a ellos, sin necesidad de personalizar su comportamiento.\nVentajas:\n\nSintaxis simple y menor código, ya que los records manejan automáticamente equals, hashCode, y toString.\nInmutabilidad por defecto, lo que es útil si no quieres que Order cambie una vez creado.\n\nDesventajas:\n\nLimitado en términos de funcionalidad: los records están diseñados para ser simples contenedores de datos, por lo que no se pueden añadir comportamientos complejos.\nPuede no ser una buena opción si Order necesita tener subclases con diferentes comportamientos."
  },
  {
    "objectID": "index.html#resumen-rápido",
    "href": "index.html#resumen-rápido",
    "title": "probamosQuarto",
    "section": "",
    "text": "Clase abstracta: Usar si Order tiene lógica compartida entre subclases.\nInterfaz: Usar si Order solo define métodos sin necesidad de lógica compartida.\nInterfaz + clase abstracta: Usar para combinar flexibilidad y reutilización de código compartido.\nClase sellada: Usar si solo quieres permitir un conjunto específico de subclases.\nRecords: Usar si Order es un simple contenedor de datos sin lógica ni subclases adicionales."
  },
  {
    "objectID": "my-quarto-site.html",
    "href": "my-quarto-site.html",
    "title": "my-quarto-site",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "my-quarto-site.html#quarto",
    "href": "my-quarto-site.html#quarto",
    "title": "my-quarto-site",
    "section": "",
    "text": "Quarto enables you to weave together content and executable code into a finished document. To learn more about Quarto see https://quarto.org."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  }
]